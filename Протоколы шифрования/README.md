При запуске клиент и сервер генерируют каждый свою пару ключей. При подключении клиент посылает серверу свой открытый ключ. В ответ сервер посылает клиенту открытый ключ. Клиент посылает сообщение серверу, шифруя его закрытым ключом и открытым ключом сервера. Сервер принимает сообщение, расшифровывает его сначала своим закрытым ключом, а потом - открытым ключом клиента. Обратное сообщение посылается аналогично. Для шифрования и расшифрования используются функции симметричного шифрования.

Файл client.py:
![image](https://user-images.githubusercontent.com/90391164/146342938-70585e8c-7e9c-44c1-bf7e-ac62b8c08877.png)

файл server.py:
![image](https://user-images.githubusercontent.com/90391164/146342979-459c9652-167e-44a8-a801-68a43402cdeb.png)
 1. Модифицируйте код клиента и сервера так, чтобы приватный и публичный ключ хранились в текстовых файлах на диске и, таким образом, переиспользовались между запусками.
 
Файлы, где хранятся ключи сервера и клиента:
![image](https://user-images.githubusercontent.com/90391164/146343136-77dcefce-3ffc-4277-9368-137e39f7bc22.png)
![image](https://user-images.githubusercontent.com/90391164/146343141-a66590d6-9442-4402-8b35-ceaa2dea9f29.png)
ключи одинаковые
2. Проведите рефакторинг кода клиента и сервера так, чтобы все, относящееся к генерации ключей, установлению режима шифрования, шифрованию исходящих и дешифрованию входящих сообщений было отделено от основного алгоритма обмена сообщениями.

созданы функции calc_part_key, calc_full_key, encoding , decoding ( можете посмотреть в самом файле server.py)
![image](https://user-images.githubusercontent.com/90391164/146343414-c51aaab3-cb2d-4a8f-b035-a68c0f0d73d7.png)

3. Реализуйте на сервере проверку входящих сертификатов. На сервере должен храниться список разрешенных ключей. Когда клиент посылает на сервер свой публичный ключ, сервер ищет его среди разрешенных и, если такого не находит, разрывает соединение. Проверьте правильность работы не нескольких разных клиентах.

хранятся в файле csv
![image](https://user-images.githubusercontent.com/90391164/146343688-5e5311d0-015b-4281-ac44-deecb6eac6fb.png)

4. Модифицируйте код клиента и сервера таким образом, чтобы установление режима шифрования происходило при подключении на один порт, а основное общение - на другом порту. Номер порта можно передавать как первое зашифрованное сообщение.
![image](https://user-images.githubusercontent.com/90391164/146343958-1049f3dd-4870-4fa6-834b-bdfe7a644dcc.png)

переключение сервера осуществляется функцией port2
5. Модифицируйте код FTP-сервера таким образом, чтобы он поддерживал шифрование. Обмен ключами и генерация происходят при каждом запросе и каждый раз разные соответственно. 
реализовано в файлах ftp_dop1.py и dop_ftp.py
Используемые функции:
![image](https://user-images.githubusercontent.com/90391164/146345695-aab449d2-4db2-4365-83c2-592a076fab54.png)
![image](https://user-images.githubusercontent.com/90391164/146346147-7c19a58d-cc2c-4cf3-82a7-7446dd3dd1e4.png)
![image](https://user-images.githubusercontent.com/90391164/146346181-3fedf05b-100b-4c16-9ee9-702eac90b442.png)


